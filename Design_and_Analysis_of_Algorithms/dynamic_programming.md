# 动态规划

- 最优子结构性质
- 子问题重叠性质
- 自底向上的求解方法

## 矩阵连乘问题

对于矩阵连乘，由于乘法是影响运行速度的主要因素，而不同的运算次序会产生不同的乘法次数，因此通过找到最优的运算次序得到最少的乘法次数，就可以提高矩阵连乘的速度。

下面是矩阵连乘最小计算次数的关系式：

i=j,m[i][j]=0
i<j,m[i][j]=min{m[i][k]+m[k+1][j]+Pi*Pk+1*Pj+1}

其中m[i][j]代表第i到j个矩阵相乘的最小次数，Pi代表矩阵i的行数(高)，Pi+1表示矩阵i的列数(宽)。

根据递推关系式，即可求出矩阵连乘的最小计算次数。注意，计算的顺序并不是很常规，而是按照与对角线平行的“行”的顺序计算的，如下表所示：

|1|6|10|13|15|
| :----: | :------: |
||2|7|11|14|
|||3|8|12|
||||4|9|
|||||5|

### 伪代码

二维数组m用来存放各个子问题的最优值，例如m[i][j]表示i...j个矩阵连乘的最优值；二维数组s用来存放各个子问题的最优决策，如如果s[i][j]=k，则表示最优的加括号方法为(Ai...Ak)(Ak+1...Aj)；一维数组P用来存放矩阵的大小，如矩阵i的大小为PixPi+1。

```
SMatrixMulti(n, size[0...n-1])
// 用动态规划解决矩阵连乘问题
// 输入：矩阵的个数n及其大小
// 输出：矩阵的最小乘法次数与最优决策表
for i from 0 to n-1:
  m[i][i]<-0  // 对角线位置全为0
for s from n-1:
  for i from 0 to s-1:
    j<-i+n-s
    m[i][j]<-m[i][i]+m[i+1][j]+P[i]*P[i+1]*P[j+1]
    s[i][j]=i
    for k from i+1 to j-1:    // 选取最优值及保存最优决策
      t=m[i][k]+m[k+1][j]+P[i]*P[k+1]*P[j+1]
      if t<m[i][j]:
        m[i][j]<-t
        s[i][j]<-k
```
通过递归地遍历最优决策表s即可得到矩阵连乘的运算次序。

## 0-1背包问题

[参见此处](https://github.com/Sunlcy/Knapsack_problem)
