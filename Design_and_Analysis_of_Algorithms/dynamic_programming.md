# 动态规划

- 最优子结构性质
- 子问题重叠性质
- 自底向上的求解方法

## 矩阵连乘问题

对于矩阵连乘，由于乘法是影响运行速度的主要因素，而不同的运算次序会产生不同的乘法次数，因此通过找到最优的运算次序得到最少的乘法次数，就可以提高矩阵连乘的速度。

下面是矩阵连乘最小计算次数的关系式：

i=j,m[i][j]=0

i<j,m[i][j]=min{m[i][k]+m[k+1][j]+Pi*Pk+1*Pj+1}

其中m[i][j]代表第i到j个矩阵相乘的最小次数，Pi代表矩阵i的行数(高)，Pi+1表示矩阵i的列数(宽)。

根据递推关系式，即可求出矩阵连乘的最小计算次数。注意，计算的顺序并不是很常规，而是按照与对角线平行的“行”的顺序计算的，如下表所示：

||A1|A2|A3|A4|A5|
|:---:| :----: | :------: |
|**A1**|1st|6th|10th|13th|15th|
|**A2**||2nd|7th|11th|14th|
|**A3**|||3rd|8th|12th|
|**A4**||||4th|9th|
|**A5**|||||5th|

### 伪代码

二维数组m用来存放各个子问题的最优值，例如m[i][j]表示i...j个矩阵连乘的最优值；二维数组s用来存放各个子问题的最优决策，如如果s[i][j]=k，则表示最优的加括号方法为(Ai...Ak)(Ak+1...Aj)；一维数组P用来存放矩阵的大小，如矩阵i的大小为PixPi+1。

```
SMatrixMulti(n, size[0...n-1])
// 用动态规划解决矩阵连乘问题
// 输入：矩阵的个数n及其大小
// 输出：矩阵的最小乘法次数与最优决策表
for i from 0 to n-1:
  m[i][i]<-0  // 对角线位置全为0
for s from n-1:
  for i from 0 to s-1:
    j<-i+n-s
    m[i][j]<-m[i][i]+m[i+1][j]+P[i]*P[i+1]*P[j+1]
    s[i][j]=i
    for k from i+1 to j-1:    // 选取最优值及保存最优决策
      t=m[i][k]+m[k+1][j]+P[i]*P[k+1]*P[j+1]
      if t<m[i][j]:
        m[i][j]<-t
        s[i][j]<-k
```
通过递归地遍历最优决策表s即可得到矩阵连乘的运算次序。

## 0-1背包问题

[参见此处](https://github.com/Sunlcy/Knapsack_problem)

## 练习

### 石子合并问题

在一个圆形操场的四周摆放着n堆石子，现要将石子有次序地合并成一堆。规定每次只能选取相邻的两堆合并成新的一堆,并将新的一堆的石子数,记为该次合并的得分。选择一种合并石子的方案,使得做n－1次合并,得分的总和最小。

- 分析：

该问题与矩阵相乘十分相似，递推关系式也基本相同，根据最优子结构以及子问题重叠的性质，我们不难得出一下的递推关系式：

i=j,m[i][j]=0

i<j,m[i][j]=m[i][k]+m[k+1][j]+totalValue

同样，我们依然采用一个二维数组m用来存放最优值，填充的顺序和矩阵连乘的顺序一致。具体可以参考上面的矩阵相乘问题的伪代码。
